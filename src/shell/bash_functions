#!/usr/bin/env bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Simple Calculator

? () {

    local result=""

    #                       ┌─ default (when --mathlib is used) is 20
    result="$( printf "scale=10;%s\n" "$*" | bc --mathlib | tr -d "\\\n" )"
    #                         remove the tailing "\" and "\n" ─┘
    #                         (large numbers are printed on multiple lines)
    # See https://www.gnu.org/software/bc/manual/html_node/bc_toc.html

    if [[ "$result" == *.* ]]; then
        # Improve the output for decimal numbers
        printf "%s" "$result" |
        sed -e "s/^\./0./"          # add "0" for cases like ".5"` \
            -e "s/^-\./-0./"        # add "0" for cases like "-.5"`\
            -e "s/0*$//;s/\.$//"    # remove tailing zeros
    else
        printf "%s" "$result"
    fi

    printf "\n"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create data URI from a file

datauri() {
    # $1 : file to generate data uri for
    local mimeType=""
    # True if file exists and is a regular file.
    if [ -f "$1" ]; then
        mimeType=$(file -b --mime-type "$1")
        #                └─ do not prepend the filename to the output

        if [[ $mimeType == text/* ]]; then
            mimeType="$mimeType;charset=utf-8"
        fi

        printf "data:%s;base64,%s" \
                    "$mimeType" \
                    "$(openssl base64 -in "$1" | tr -d "\n")"
        #                │       │                │  └── Delete characters in string argument from string passed in
        #                │       │                └── translate characters command
        #                │       └── base64 encode file
        #                └── convert input text to open ssl format? (technically this isn't actually needed)
    else
        printf "%s is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Delete files that match a certain pattern from the current directory
# This lists the files deleted via the -ls option

delete-files() {
    # $1 : file pattern to search for files to delete
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
    #    |       |         |   |   └─── delete found files (or directories)
    #    │       │         │   └─── list file information
    #    │       │         └─── pattern of filename to search for
    #    │       └──── search for files
    #    └────── current directory to recursively traverse to find files
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search git repositories from current director and display report with
# remote information

git-remotes-list() {
    echo "*********************************************************************"
    echo "$PWD"
    echo "*********************************************************************"
    find -L . -name .git -type d  | while read -r d; do
       cd "$d/.." || exit
       # Same as: echo "$PWD" | sed -e 's|'"$OLDPWD"'||'
       echo "${PWD//$OLDPWD/}"
       printf "%s\n" "$(git remote -v | sed -e 's/^\(.*\)$/    \1/')"
       cd "$OLDPWD" || exit
    done
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get gzip information (gzipped file size + reduction size)

gz() {
    # $1 : file to get gzip information from

    # declare integers
    declare -i gzippedSize=0
    declare -i originalSize=0

    # -f: True if file exists and is a regular file.
    if [ -f "$1" ]; then
        # -s : True if file exists and has a size greater than zero.
        if [ -s "$1" ]; then

            originalSize=$( wc -c < "$1" )
            # %12s\n : 12 chars long, convert to string, append \n
            # See http://en.cppreference.com/w/cpp/io/c/fprintf
            printf "\n original size:   %12s\n" "$(hrfs "$originalSize")"

            # gzip -c to standard output
            gzippedSize=$( gzip -c "$1" | wc -c )
            printf " gzipped size:    %12s\n" "$(hrfs "$gzippedSize")"

            printf " ─────────────────────────────\n"
            printf " reduction:       %12s [%s%%]\n\n" \
                        "$( hrfs $((originalSize - gzippedSize)) )" \
                        "$( printf "%s" "$originalSize $gzippedSize" | \
                            awk '{ printf "%.1f", 100 - $2 * 100 / $1 }' | \
                            sed -e "s/0*$//;s/\.$//" )"
                            #              └─ remove tailing zeros

        else
            printf "\"%s\" is empty.\n" "$1"
        fi
    else
        printf "\"%s\" is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Human readable file size
# (because `du -h` doesn't cut it for me)

hrfs() {
    # $1 : number to convert to file size

    printf "%s" "$1" |
    awk '{
            i = 1;
            split("B KB MB GB TB PB EB ZB YB WTFB", v);
            value = $1;

            # confirm that the input is a number
            if ( value + .0 == value ) {

                while ( value >= 1024 ) {
                    value/=1024;
                    i++;
                }

                if ( value == int(value) ) {
                    printf "%d %s", value, v[i]
                } else {
                    printf "%.1f %s", value, v[i]
                }

            }
        }' |
    sed -e ":l" -e "s/\([0-9]\)\([0-9]\{3\}\)/\1,\2/" -e "t l"
    #                             └─ add commas to the numbers
    #                                (changes "1023.2 KB" to "1,023.2 KB")
    # See http://www.grymoire.com/Unix/Sed.html
    # -e  : combine multiple commands by using -e before each command
    # :l  : create label
    # t l : execute code at label if a pattern match is found
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Return relative path to $1 from $2
# Example:
#   `relpath /foo/bar /foo/baz/foo` return `../../bar`

relpath() {
  # http://www.tldp.org/LDP/abs/html/parameter-substitution.html
  # $1 : Path we wish to get relative path for
  # $2 : Path from which to generate relative path from
  python -c "import os.path; print (os.path.relpath('$1','${2:-$PWD}'))" ;
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create new directories and enter the first one

mkcd() {
    # $* : arguments passed to mkd which is the directories to create
    # -n : True if the length of string is nonzero.
    if [ -n "$*" ]; then

        mkdir -p "$@"
        #      └─ make parent directories if needed

        cd "$@" \
            || exit 1

    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search history

qh() {
    # $* : arguments passed to qh which is the search text
    # HISTFILE : https://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html
    #
    #           ┌─ enable colors for pipe
    #           │  ("--color=auto" enables colors only if
    #           │  the output is in the terminal)
    grep --color=always "$*" "$HISTFILE" |   /usr/bin/less -RX
    #      display ANSI color escape sequences in raw form ─┘│
    #            don't clear the screen after quitting less ─┘
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search for text recursively within the current directory

qt() {
    # $* : arguments passed to qt which is the search text
    grep -ir --color=always "$*" --exclude-dir=".git" . | /usr/bin/less -RX
    #     │└─ search all files under each directory, recursively
    #     └─ ignore case
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# http://apple.stackexchange.com/questions/139807/what-does-update-terminal-cwd-do-in-the-terminal-of-os-x
# Supposed to be defined in /etc/bashrc but was missing and was being called by tmux-resurrect
update_terminal_cwd() {
    # Identify the directory using a "file:" scheme URL,
    # including the host name to disambiguate local vs.
    # remote connections. Percent-escape spaces.
    local SEARCH=' '
    local REPLACE='%20'
    local PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}"
    printf '\e]7;%s\a' "$PWD_URL"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Upgrade jenv if it is installed

upgrade-jenv() {

    declare -r JENV_DIRECTORY="$HOME/.jenv"

    if [ -d "$JENV_DIRECTORY" ]; then # -d : True if file exists and is a directory.
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # Ensure the latest version of `jenv` is used

        execute \
            "cd $JENV_DIRECTORY \
                && git fetch --quiet origin \
                && git checkout --quiet \$(git describe --abbrev=0 --tags) \
                && . $HOME/.bash.local \
                && cd -" \
            "jenv (upgrade)"

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Upgrade nvm if it is installed

upgrade-nvm() {

    declare -r NVM_DIRECTORY="$HOME/.nvm"

    if [ -d "$NVM_DIRECTORY" ]; then # -d : True if file exists and is a directory.

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # Ensure the latest version of `nvm` is used

        execute \
            "cd $NVM_DIRECTORY \
                && git fetch --quiet origin \
                && git checkout --quiet \$(git describe --abbrev=0 --tags) \
                && . $NVM_DIRECTORY/nvm.sh \
                && cd -" \
            "nvm (upgrade)"

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    fi
}
